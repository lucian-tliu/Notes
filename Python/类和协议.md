# 类和协议

## 1 符合 Python 风格的对象

前面介绍了很多内置对象的行为和用法，现在我们需要学会自己定义一个符合“Python 风格”的类（让自定义的类向 Python 内置类型那样工作），比如实现一些 Python 中常见的特殊方法等。

>   [!note]
>
>   一个 Python 风格的二维向量类
>
>   ```python
>   """
>   A two-dimensional vector class
>   
>       >>> v1 = Vector2d(3, 4)
>       >>> print(v1.x, v1.y)
>       3.0 4.0
>       >>> x, y = v1
>       >>> x, y
>       (3.0, 4.0)
>       >>> v1
>       Vector2d(3.0, 4.0)
>       >>> v1_clone = eval(repr(v1))
>       >>> v1 == v1_clone
>       True
>       >>> print(v1)
>       (3.0, 4.0)
>       >>> octets = bytes(v1)
>       >>> octets
>       b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'
>       >>> abs(v1)
>       5.0
>       >>> bool(v1), bool(Vector2d(0, 0))
>       (True, False)
>   
>   
>   Test of ``.frombytes()`` class method:
>   
>       >>> v1_clone = Vector2d.frombytes(bytes(v1))
>       >>> v1_clone
>       Vector2d(3.0, 4.0)
>       >>> v1 == v1_clone
>       True
>   
>   
>   Tests of ``format()`` with Cartesian coordinates:
>   
>       >>> format(v1)
>       '(3.0, 4.0)'
>       >>> format(v1, '.2f')
>       '(3.00, 4.00)'
>       >>> format(v1, '.3e')
>       '(3.000e+00, 4.000e+00)'
>   
>   
>   Tests of the ``angle`` method::
>   
>       >>> Vector2d(0, 0).angle()
>       0.0
>       >>> Vector2d(1, 0).angle()
>       0.0
>       >>> epsilon = 10**-8
>       >>> abs(Vector2d(0, 1).angle() - math.pi/2) < epsilon
>       True
>       >>> abs(Vector2d(1, 1).angle() - math.pi/4) < epsilon
>       True
>   
>   
>   Tests of ``format()`` with polar coordinates:
>   
>       >>> format(Vector2d(1, 1), 'p')  # doctest:+ELLIPSIS
>       '<1.414213..., 0.785398...>'
>       >>> format(Vector2d(1, 1), '.3ep')
>       '<1.414e+00, 7.854e-01>'
>       >>> format(Vector2d(1, 1), '0.5fp')
>       '<1.41421, 0.78540>'
>   
>   
>   Tests of `x` and `y` read-only properties:
>   
>       >>> v1.x, v1.y
>       (3.0, 4.0)
>       >>> v1.x = 123
>       Traceback (most recent call last):
>       ...
>       AttributeError: can't set attribute 'x'
>   
>   
>   Tests of hashing:
>   
>       >>> v1 = Vector2d(3, 4)
>       >>> v2 = Vector2d(3.1, 4.2)
>       >>> len({v1, v2})
>       2
>   
>   """
>   
>   from array import array
>   import math
>   
>   class Vector2d:
>       __match_args__ = ('x', 'y')
>   
>       typecode = 'd'
>   
>       def __init__(self, x, y):
>           self.__x = float(x)
>           self.__y = float(y)
>   
>       @property
>       def x(self):
>           return self.__x
>   
>       @property
>       def y(self):
>           return self.__y
>   
>       def __iter__(self):
>           return (i for i in (self.x, self.y))
>   
>       def __repr__(self):
>           class_name = type(self).__name__
>           return '{}({!r}, {!r})'.format(class_name, *self)
>   
>       def __str__(self):
>           return str(tuple(self))
>   
>       def __bytes__(self):
>           return (bytes([ord(self.typecode)]) +
>                   bytes(array(self.typecode, self)))
>   
>       def __eq__(self, other):
>           return tuple(self) == tuple(other)
>   
>       def __hash__(self):
>           return hash((self.x, self.y))
>   
>       def __abs__(self):
>           return math.hypot(self.x, self.y)
>   
>       def __bool__(self):
>           return bool(abs(self))
>   
>       def angle(self):
>           return math.atan2(self.y, self.x)
>   
>       def __format__(self, fmt_spec=''):
>           if fmt_spec.endswith('p'):
>               fmt_spec = fmt_spec[:-1]
>               coords = (abs(self), self.angle())
>               outer_fmt = '<{}, {}>'
>           else:
>               coords = self
>               outer_fmt = '({}, {})'
>           components = (format(c, fmt_spec) for c in coords)
>           return outer_fmt.format(*components)
>   
>       @classmethod
>       def frombytes(cls, octets):
>           typecode = chr(octets[0])
>           memv = memoryview(octets[1:]).cast(typecode)
>           return cls(*memv)
>   ```

### 1.1 对象表示形式

Python 提供以下几种获取对象字符串表示形式的标准方式（特殊方法）

-   `__repr__`：以便于**开发者**理解的方式返回对象的字符串表示形式。Python 控制台或调试器在显示对象时采用这种方式。对应函数为 `repr()`
-   `__str__`：以便于**用户**理解的方式返回对象的字符串表示形式。使用 `print()` 打印对象时采用这种方式。对应函数为 `str()``
-   ``__format__(format_spec)`：以特殊的格式化代码显示对象的字符串表示形式。对应函数或方法为 `format()` 和 `str.format()`，以及 `f` 字符串

    -   其中 `format_spec` 是格式说明符，它是 `format(my_obj, format_spec)` 的第二个参数，也是 `f` 字符串内 `{}` 内代换字段中冒号右边的部分（左边是字段名），还是 `fmt.str.format()` 中的 `fmt`

    -   格式说明符使用的表示法叫做**格式规范微语言**(format specification mini-language)，它为一些内置类型提供了专用的表示代码：

        -   整数：`'b'`、`'c'`、`'d'`、`'o'`、`'x'`、`'X'`、`'n'`，其中 `b` 和 `x` 表示二进制和十六进制

        -   浮点数：`'e'`、`'E'`、`'f'`、`'F'`、`'g'`、`'G'`、`'n'`、`'%'`，其中`f` 和 `%` 表示小数形式和百分数
            ```python
            >>> format(2 / 3, '.1%')
            '66.7%'
            ```

        -   字符串：`s`

        -   转换标志：`!s`、`!r`、`!a`

    -   格式规范微预言是可扩展的，各类可自定义如何解释 `format_spec` 参数

    -   如果一个类没有定义 `__format__` 方法，那么该方法就会从 `object` 继承，并返回 `str(my_object)`，此时若传入格式说明符，则 `object.__format__` 会抛出 `TypeError`

### 1.2 备选构造函数

在自定义类时，可能需要不止一种创建实例的构造函数（从不同的输入创建实例）。除了默认的 `__init__` 方法外，我们还可以自定义方法，作为备选的构造函数。通常会配合 `classmethod` 装饰器来定义备选构造函数，它的作用是：定义操作类而不是操作实例的方法，此时该方法接收的第一个参数是类本身（通常取名为 `cls`）而非实例（`self`）。

还有一个装饰器 `staticmethod`，它也会改变方法的调用方式，使其变得像一个普通函数一样。

### 1.3 可哈希的对象

为了让对象变得可哈希，需要：

-   必须实现 `__hash__` 方法和 `__eq__` 方法

-   让实例不可变（使属性变为只读）

    -   使用两个前导下划线 `__`，将属性标记为“私有”
    -   用 `@property` 装饰器将读值方法 (getter) 标记为特性 (property)

    ```python
    class My_Class:
        def __init__(self, x, y):
            self.__x = float(x)
            self.__y = float(y)
    
        @property
        def x(self): # 读值方法与公开属性同名
            return self.__x
    
        @property
        def y(self):
            return self.__y
    ```

#### “私有”属性和“受保护”的属性

之所以将“私有”属性打引号，是因为 Python 实际上无法像 C++ 那样使用 `private` 修饰符创建私有属性，但是可以用 `__` 前导实现类似功能。带这一前导的属性名会被存入实例属性 `__dict__` 中，而且这个属性的前面会加上一个下划线和类名（比如 `__x` 会变成 `_My_Class__x`）。这个功能成为**名称改写**(name mangling)，它的目的是避免意外访问，但不能防止故意的破坏，因为只要知道改写私有属性名称的机制，任何人都能直接读取私有属性。

```python
>>> v = Vector2d(3, 4)
>>> v.__dict__
{'_Vector2d__x': 3.0, '_Vector2d__y': 4.0}
>>> v._Vector2d__x
3.0
```

但是有不少 Python 程序员不喜欢这种双下划线前缀，因此他们约定：带单个下划线前缀的属性是“受保护”的属性。虽然 Python 解释器不会对这样的属性名做特殊处理，但不少程序员均遵守这一约定，就和遵守常量名大写的约定一样。

不过，在模块中，如果顶层名称使用一个前导下划线，那么的确会有影响：

-   对 `from mymod import *` 来说，`mymod` 中前缀为一个下划线的名称不会被导入
-   然而，可以通过具体指明该名称的方式来导入，比如 `from mymod import _privatefunc`

### 1.4 支持位置模式匹配

如果自定义类能够保存好类的属性，并且使类的实例成为可迭代对象，那么该实例应当支持关键字类模式。

```python
def keyword_pattern_demo(v: Vector2d) -> None:
    match v:
    	case Vector2d(x=0, y=0):
    		print(f'{v!r} is null')
        case Vector2d(x=0):
        	print(f'{v!r} is vertical')
        case Vector2d(y=0):
        	print(f'{v!r} is horizontal')
        case Vector2d(x=x, y=y) if x==y:
        	print(f'{v!r} is diagonal')
        case _:
        	print(f'{v!r} is awesome')
```

然而，要想让实例支持位置模式，需要为类添加一个名为 `__match_args__` 的类属性，按照在位置模式匹配中的使用顺序列出实例属性。

```python
		case Vector2d(_, 0):
 			print(f'{v!r} is horizontal')
```

```python
class Vector2d:
	__match_args__ = ('x', 'y')
	# etc...
```

-   `__match__args__` 应当列出必需的参数，可选的参数则不必列出

### 1.5 使用__slots__节省空间

默认情况下，Python 把各个实例的属性存储在 `__dict__` 字典中，但是字典消耗的内存很多。优化方法是使用 `__slots__` 存储实例属性，它会将属性名称存储在一个隐藏的引用数组中，因此消耗的内存比字典少。

-   `__slots__` 必须在定义类时声明（紧跟 `class` 语句的下一行），之后再添加或修改均无效
-   属性名称可以存储在一个元组或列表中，而存储在元组中可以明确表明 `__slots__` 无法修改
-   若设置了 `__slots__`，则无法访问该实例的 `__dict__` 属性
-   设定不在 `__slots__` 中的属性会抛出 `AttributeError`
-   子类只能继承 `__slots__` 的部分效果，因此对于设置了 `__slots__` 的类，它的子类需要再次声明 `__slots__` 属性
-   如果子类的 `__slots__ = ()`（空元组），表示子类仅接受基类的 `__slots__` 属性列出的属性名称；若子类需要额外属性，则在子类的 `__slots__` 属性中列出来
-   若将 `'__dict__'` 添加到 `__slots__` 列表中，则实例会在各个实例独有的引用数组中存储 `__slots__` 的名称，不过也支持动态创建属性，存储在常规的 `__dict__` 中
-   若定义了 `__slots__`，且想把该类的实例作为弱引用的目标，则必须把 `'__weakref__'` 添加到 `__slots__` 中

### 1.6 覆盖类属性

在 Python 中，**实例属性**是在类定义中声明的，并以 `self.` 开头的变量；而类属性是在类定义中声明的，但不以 `self.` 开头的变量。

-   Python 中，类属性可为实例属性提供默认值
-   如果为不存在的实例属性赋值，那么将会创建一个新实例属性，它会覆盖同名的类属性
-   如果想修改类属性的值，那么必须直接在类上修改，无法通过实例修改；如果想修改所有实例属性的默认值，则可通过 `My_Class.attr = val` 来修改
-   另一种方式是创建一个子类，用子类中的类属性覆盖

## 2 序列特殊方法

-   序列类型的构造函数最好接受可迭代对象为参数
-   如果序列类型的实例包含的项超过 6 个，那么 `repr()` 生成的字符串就会使用 `...` 省略其余项的表示，因为 `repr` 是用于调试的，一般而言在控制台或日志上输出成千上万行的内容是不太合理的
    -   同样因为调试目的，`repr()` 绝对不能抛出异常，如果实现方法有问题，应尽量输出有用的内容，让用户能够识别
    -   可以用 `reprlib` 模块中的 `repr` 函数自动对返回的字符串进行截断，并添加"..."来表示被截断的部分
-   根据前面介绍的鸭子类型，只要让类的**行为**像序列，那么它的实例就是一个序列。要做到这一点，Python 的序列协议（具体概念见下面）只需要 `__len__` 和 `__getitem__` 两个方法即可。

### 2.1 协议和鸭子类型

-   在面向对象编程中，**协议**(protocol)是非正是的接口，只在文档中定义，不在代码中定义
-   协议是非正式的，没有强制力，因此如果知道类的具体使用场景，通常只需要实现协议的一部分
-   Python 3.8 开始支持协议类（即 `typing.Protocol`），这里的“协议”与上面给出的概念不同，具体可分为：
    -   静态协议：协议类规定的协议，这类协议的实现必须提供静态类中定义的所有方法
    -   动态协议：传统意义上的协议
-   在 Python 文档中，如果看到“文件类对象”这样的表述，通常说的就是协议，它的意思是：“行为基本与文件一致，实现了部分文件接口，满足上下文相关需求的东西。”

### 2.2 可切片的序列

Python 中通过调用 `seq.__getitem__(slice(start, end, step))` 获得切片，我们期望的切片行为是：切片得到的都是各自类型的实例。

-   使用 `dir(slice)` 可以看到 `slice` 存在一个方法 `indices`

    ```
    S.indices(len) -> (start, stop, stride)
    
    Assuming a sequence of length len, calculate the start and stop indices, and the stride length of the extended slice described by S. Out of bounds indices are clipped in a manner consistent with the handling of normal slices.
    ```

    通过这个方法可以方便的处理索引越界和负索引。

-   下面的 `__getitem__` 可以给出我们预期的行为

    ```python
    def __getitem__(self, key):
        if isinstance(key, slice):               # 如果 key 是 slice 对象
            cls = type(self)                     # 获取构造实例的类
            return cls(self._components[key])    # 调用类的构造函数，创建新的实例
        index = operator.index(key)              # key 是单个索引
        return self._components[index]
    ```

    注：这个 `__getitem__` 不能处理多维索引，使用元组索引会抛出错误
    
    -   `operator.index()` 背后调用特殊方法 `__index__`，它只有一个用处：判断 `key` 是否为整数

### 2.3 动态存取属性

在单纯的序列中，只能通过 `v[i]` 获取项。但如果能够使用 `x, y, z` 访问 `v[0], v[1], v[3]` 等几个元素，则会更为方便

-   可以用上一节介绍的 `@property` 装饰器为每个属性定义一个读值方法，但这样比较麻烦
-   更简便的方式是使用特殊方法 `__getattr__`，它的机制如下：
    1.   对于 `my_obj.x` 表达式，Python 会检查 `my_obj` **实例**有没有名为 `x` 的属性
    1.   如果没有，就到 `my_obj.__class__` 里查找
    1.   若还没有，就沿着继承图继续往上找
    1.   若依旧找不到，则调用 `my_obj` 所属类中定义的 `__getattr__` 方法，传入 `self` 和属性名称的字符串形式（`'x'`）

```python
	__match_args__ = ('x', 'y', 'z', 't') 

    def __getattr__(self, name):
        cls = type(self) 
        try:
        	pos = cls.__match_args__.index(name) 
        except ValueError: 
        	pos = -1
        if 0 <= pos < len(self._components): 
        	return self._components[pos]
        msg = f'{cls.__name__!r} object has no attribute {name!r}' 
        raise AttributeError(msg)
```

-   结合 `__match_args__`，让 `__getattr__` 实现的动态属性支持位置模式匹配
-   在实现 `__getattr__` 时，可以设置 `AttributeError` 错误信息，以应对不合预期的行为

上面的方法任然会出现一些问题，根据前面的属性查找机制，如果运行过程中为实例属性赋值，那么实例属性就会覆盖 `__getattr__` 方法，使得该方法无法再被调用。解决方法是实现 `__setattr__` 方法（只要对实例属性赋值，就会调用这个特殊方法），以限制实例属性的赋值

```python
def __setattr__(self, name, value):
    cls = type(self)
    if len(name) == 1: 
    	if name in cls.__match_args__: 
    	error = 'readonly attribute {attr_name!r}'
    elif name.islower(): 
    	error = "can't set attributes 'a' to 'z' in {cls_name!r}"
    else:
    	error = '' 
    if error: 
    	msg = error.format(cls_name=cls.__name__, attr_name=name)
    raise AttributeError(msg)
    super().__setattr__(name, value)
```

-   对于被限制的属性，需要在 `__setattr__` 中编写合适的处理方式；对于其他属性，默认采用超类的 `__setattr__` 方法，即调用 `super().__setattr__()`

一个 `complex` 类型的例子

```python
>>> a = 1 + 2j
>>> type(a)
<class 'complex'>
>>> a.real
1.0
>>> a.real = 2
Traceback (most recent call last):
  File "<python-input-3>", line 1, in <module>
    a.real = 2
    ^^^^^^
AttributeError: readonly attribute
```

*一般情况下，实现了 `__getattr__` 方法，则也应定义 `__setattr__`，以防对象的行为不一致*

### 2.4 哈希和快速等值测试

对于包含大量项的序列，要实现其所属类的 `__hash__` 方法，如果直接对整个序列使用 `hash()` 函数，由于需要构建整个序列，因此消耗的资源较多，不太合适。更合理的做法是：使用 `^`（异或）运算符计算所有项（或对应的哈希值），将计算结果作为哈希值。在具体实现中，`functools.reduce` 归约函数是最能胜任这一任务的方式：

```python
# 创建生成器表达式，惰性计算各个分量的哈希值
hashes = (hash(x) for x in self._components) # 也可使用map函数
# 使用 xor 函数计算聚合的哈希值，第三个参数是初始值
functools.recude(operator.xor, hashes, 0)
```

-   `reduce` 函数将序列聚合为一个数值

----

对于等值比较，可以通过形如 `tuple(self) == tuple(other)` 的方式，这样方式实现简单，但需要复制两个完整的列表，如果序列中包含很多项，效率就会很低。为提高效率

-   比较两个序列的长度
-   依次比较两个序列相同位置上的项

```python
def __eq__(self, other):
    return len(self) == len(other) and all(a == b for a, b in zip(self, other))
    # 归约函数 all() 只有当所有比较结果为真时返回 True，有一个错的就返回 False
```

zip 函数名称来自 zipper，将任意个可迭代对象对应项咬合在一起：

-   `zip(*iterables, strict=False)`，并行迭代若干个可迭代对象。
-   `strict=False` 情况，当其中一个可迭代对象耗尽时，`zip` 不发出警告就停止执行。
-   `strict=True` 时，如果可迭代对象长度不同，则抛出 ValueError（快速失败）
-   `itertools.zip_longest` 使用可选的 `fillvalue`（默认值为 `None`）来填充缺失值，因此可以继续生成元组，直到最后一个可迭代对象耗尽
