# 函数即对象

## 1 函数是一等对象

**一等对象**(first-class object) 指的是满足以下条件的程序实体：

- 在运行时创建
- 能赋值给变量或数据结构中的元素
- 能作为参数传给函数
- 能作为函数的返回结果

在 Python 中，函数也符合上述条件，因此函数是一等对象。

> I have never considered Python to be heavily influenced by functional languages, no matter what people say or think. I was much more familiar with imperative languages such as C and Algol 68 and although I had made functions first-class objects, I didn't view Python as a functional programming language.     ——Gudio van Rossum

- `__doc__` 属性用于生成对象的帮助文本
- 可以将函数直接复制给变量，然后通过变量名调用该函数

### 1.1 高阶函数

**高阶函数**(higher-order function)：接受函数为参数，或把函数作为结果返回的函数。

内置函数 `sorted`、`map`、`filter`、`reduce` 等都属于高阶函数

- `map(function, iterable)`：返回一个可迭代对象，所含的项是把第一个参数（函数）应用到第二个参数（一个可迭代对象）中各个元素得到的结果
  - 在 Python 3 中，`map` 函数是惰性的，它会创建一个生成器，按需产出结果，因此能节省内存
- 可以用更为现代和方便的列表推导式和生成器表达式可以替代 `map` 和 `filter`
- `reduce` 归约函数来自 `functools` 模块，它的句法与 `map` 类似，作用是将一系列值归约成单个值
  - `reduce` 还有可选的第三个参数，作为初始值，但建议最好提供这个参数。如果可迭代对象为空，那么返回值就是这个初始值；否则在归约循环中，以这个初始值作为第一个参数（例如，对 `+`、`|`、`^` 来说，初始值应为 0，而对 `*` 和 `&` 来说，初始值应为 1）

- 内置的归约函数还有：
  - `all(iterable)`：`iterable` 中没有表示假值的元素时返回 `True`
  - `any(iterable)`：`iterable` 中只要有元素是真值就返回 `True`

### 1.2 匿名函数

**匿名函数**，即没有名称的函数，在 Python 中由 lambda 关键字实现。

- lambda 函数的主体只能是表达式，因此像 `while`、`try`，乃至 `=` 赋值等语句都不允许出现在 lambda 函数的主体部分
- 但是可以用 `:=` 赋值表达式，不过这种情况下的 lambda 函数可能过于复杂，建议用 `def` 定义方法重构函数
- lambda 函数主要的作用是作为高阶函数的参数，除此之外很少会用到 lambda 函数

### 1.3 可调用对象

可调用对象指的是可以使用调用运算符 `()` 的对象，可以用内置的 `callable()` 函数判断。Python 3.9 后的版本提供以下几种可调用对象：

- 用户定义的函数：使用 `def` 语句或 `lambda` 表达式创建的函数
- 内置函数：使用 C 语言（CPython）实现的函数
- 内置方法：使用 C 语言实现的方法
- 方法：在类主体中定义的函数
- 类：调用类时运行 `__new__` 方法创建一个实例，然后运行 `__init__` 方法来初始化实例，最后再将实例返回给调用方
- 类的实例：若类定义了 `__call__` 方法，那么它的实例可以作为函数调用
- 生成器函数：主体中有 `yield` 关键字的函数或方法。调用生成器函数返回一个生成器对象
- 原生协程函数：使用 `async def` 定义的函数或方法。调用原生协程函数返回一个协程对象
- 异步生成器函数：使用 `async def` 定义，且主体中有 `yield` 关键字的函数或方法。调用异步生成器函数返回一个异步生成器，供 `async for` 使用

### 1.4 用户定义的可调用类型

通过实现实例方法 `__call__`，我们便可以使任何 Python 对象都能像函数一样被调用。例如

```python
import random

class BingoCage:

    def __init__(self, items):
        self._items = list(items)
        random.shuffle(self._items)

    def pick(self):
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError('pick from empty BingoCage')

    def __call__(self):
        return self.pick()
```

运行结果为

```python
>>> bingo = BingoCage(range(3))
>>> bingo.pick()
0
>>> bingo()
1
>>> callable(bingo)
True
```

- 实现 `__call__` 方法后，必须在内部维护一个状态，让它在多次调用之间存续（涉及到闭包）
- `__call__` 的另一个用处是实现装饰器

### 1.5 形参声明句法

#### 1.5.1 仅限关键字参数

定义函数时，在参数列表中加入参数 `*`，`*` 后面（右边）的参数就是仅限关键字参数，即调用时一定要指出参数名称的参数。

```python
>>> def f(a, *, b):
...     return a, b
...     
>>> f(1, b=2)
(1, 2)
>>> f(1, 2)
Traceback (most recent call last):
File "<python-input-2>", line 1, in <module>
    f(1, 2)
    ~^^^^^^
TypeError: f() takes 1 positional argument but 2 were given
```

#### 1.5.2 仅限位置参数

定义函数时，在参数列表中加入参数 `/`，`/` 前面（左边）的参数就是仅限位置参数，即调用时不能指出参数名称的参数。在 `/` 后面的参数不会受到影响

```python
>>> def divmod(a, b, /):
...     return (a // b, a % b)
... 
>>> divmod(10, 4)
(2, 2)
>>> divmod(a=10, b=4)
Traceback (most recent call last):
File "<python-input-5>", line 1, in <module>
    divmod(a=10, b=4)
    ~~~~~~^^^^^^^^^^^
TypeError: divmod() got some positional-only arguments passed as keyword arguments: 'a, b'
```

> [!note]
>
> Python 中可以在函数参数列表中使用 `*args` 和 `**kwargs` 捕获剩余的位置参数和关键字参数
>
> ```python
> def tag(name, *content, class_=None, **attrs):
>  """Generate one or more HTML tags"""
>  if class_ is not None:
>  attrs['class'] = class_
>  attr_pairs = (f' {attr}="{value}"' for attr, value
>  in sorted(attrs.items()))
>  attr_str = ''.join(attr_pairs)
>  if content:
>  elements = (f'<{name}{attr_str}>{c}</{name}>'
>  for c in content)
>  return '\n'.join(elements)
>  else:
>  return f'<{name}{attr_str} />'
> ```
>
> 在 `*args` 之后的参数只能按关键字传入，比如例子中的 `class_`

### 1.6 函数式编程

由于一等函数和 `operator`、`functools`等模块，Python 也支持函数式编程风格

#### 1.6.1 operator 模块

在函数式编程中，经常需要把算术运算符当作函数使用，而 Python 的 `operator` 模块提供了这样的函数。下面列出了 `operator` 模块中定义的部分函数列表（省略以 `_` 开头的名称，因为它们基本上是实现细节）：

```python
>>> [name for name in dir(operator) if not name.startswith('_')]
['abs', 'add', 'and_', 'attrgetter', 'call', 'concat', 'contains', 
'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 
'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 
'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 
'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 
'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 
'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 
'truth', 'xor']
```

- 大部分函数的功能可以从它们的名称中直接看出来
- 以 `i` 开头的函数对应增量赋值运算符的形式（例如 `+=`、`*=`）：若第一个参数是可变类型，则函数会就地修改第一个参数；否则的话直接返回运算结果，不修改参数

`operator` 模块中还有一些工厂函数：

- `itemgetter`：从序列中读取项。该函数接受单个或多个索引（`int` 类型），返回一个函数，用于提取序列中对应索引处的项，对于多个索引会打包成一个元组

  ```python
  >>> metro_data = [
  ...     ('Tokyo', 'JP', 36.933),
  ...     ('Delhi NCR', 'IN', 21.935),
  ...     ('Mexico City', 'MX', 20.142),
  ...     ('New York-Newark', 'US', 20.104),
  ...     ('Sao Paulo', 'BR', 19.648),
  ... ]                                                                                                                               
  >>> from operator import itemgetter                                                                                                 
  >>> cc_name = itemgetter(1, 0)                                                                                                      
  >>> for city in metro_data:
  ...     print(cc_name(city))
  ... 
  ('JP', 'Tokyo')
  ('IN', 'Delhi NCR')
  ('MX', 'Mexico City')
  ('US', 'New York-Newark')
  ('BR', 'Sao Paulo')
  ```

- `attrgetter`：从对象中读取属性。该函数接受单个或多个属性名（`str` 类型），返回一个函数，用于提取对象中对应的属性，对于多个属性会打包成一个元组

  - 如果属性名中包含 `.`，那么函数就会深入嵌套对象，检索属性

  ```python
  >>> from collections import namedtuple
  >>> Metropolis = namedtuple('Metropolis', 'name cc pop')
  >>> metro_areas = [Metropolis(name, cc, pop) for name, cc, pop in metro_data]
  >>> metro_areas[0]
  Metropolis(name='Tokyo', cc='JP', pop=36.933)
  >>> from operator import attrgetter
  >>> name_pop = attrgetter('name', 'pop')
  >>> 
  >>> for city in sorted(metro_areas, key=attrgetter('pop')):
  ...     print(name_pop(city))
  ... 
  ('Sao Paulo', 19.648)
  ('New York-Newark', 20.104)
  ('Mexico City', 20.142)
  ('Delhi NCR', 21.935)
  ('Tokyo', 36.933)
  ```

- `methodcaller`：会在对象上调用参数指定的方法。第一个参数为 `str` 类型，表示方法名称，后面的参数作为该方法的参数（或者说冻结了一些参数）；返回的是一个可调用的方法

  ```python
  >>> from operator import methodcaller
  >>> s = 'The time has come'
  >>> upcase = methodcaller('upper')
  >>> upcase(s)
  'THE TIME HAS COME'
  >>> hyphenate = methodcaller('replace', ' ', '-')
  >>> hyphenate(s)
  'The-time-has-come'
  ```

#### 1.6.2 functools.partial 冻结参数

另一种可以冻结参数的函数是 `functools.partial`，它可以根据提供的可调用对象产生一个新可调用对象，为原可调用对象的某些参数绑定预定的值。

- 该函数返回的是一个 `functools.partial` 对象
- 该对象提供了访问原函数、固定参数和关键字参数的属性 `.func` 、`.args` 和 `.keywords`

```python
>>> from tagger import tag
>>> tag
<function tag at 0x0000020BC5E68B80>
>>> from functools import partial
>>> picture = partial(tag, 'img', class_='pic-frame')
>>> picture(src='wumpus.jepg')
'<img class="pic-frame" src="wumpus.jepg" />'
>>> picture
functools.partial(<function tag at 0x0000020BC5E68B80>, 'img', class_='pic-frame')   
>>> picture.func
<function tag at 0x0000020BC5E68B80>
>>> picture.args
('img',)
>>> picture.keywords
{'class_': 'pic-frame'}
```

## 2 函数中的类型提示

> It should also be emphasized that **Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.**
>
> ——Guido van Rossum, Jukka Lehtosalo, Łukasz Langa "PEP 484"

### 2.1 渐进式系统

**渐进式类型系统**(gradual type system) 具有以下性质：

- 是可选的：默认情况下，类型检查工具不应对没有类型提示的代码发出警告。当类型检查工具无法确定对象的类型时，会假定其为与其他所有类型都兼容的 `Any` 类型
  - 可以通过特殊的注释让类型检查工具忽略代码中指定的行，比如在导入的包旁添加注释 `# type: ignore` 便可以禁止 Mypy 报告类型提示的问题
  - 类型检查工具通常不允许变量的类型发生变化
- 不在运行时捕获错误：类型提示相关的问题由静态类型检查工具、lint 程序或 IDE 捕获。在运行时不能阻止把不一致的值传给函数或分配给变量
  - 类型检查工具可以从表达式中推导出结果的类型
- 不能改善性能：到目前为止，任何 Python 运行时都没有根据类型提示来实现一定的优化

对于函数参数和返回值的类型提示的句法为

```python
def func_name(var_name: type_name = default_value) -> return_type:
    func_body
```

最常用的类型检查工具 [Mypy](https://github.com/python/mypy)，可以用它来体验 Python 的渐进式类型系统。

- 使用：`mypy test.py`，如果输出结果的最后一行出现 `Success` 绿色字样，表明 Mypy 没有发现问题；否则的话 Mypy 就会报告 `error`（错误） 或 `note`（提示）

- 可用命令行选项（以下选项会使 Mypy 检查更严格）：

  - `--disallow-untyped-defs`：Mypy 报告没有为参数和返回值添加类型的函数定义
  - `--disallow-incomplete-defs`：Mypy 报告没有添加完整类型提示（比如只为返回值添加注解，而参数没有注解）的函数定义
  - `--disallow-any-expr`：不允许表达式中出现 `Any` 类型

- 可以通过 mypy.ini 配置文件设置 Mypy 命令行选项，避免每次执行命令时都要输入长长的选项
  ```ini
  [mypy]
  python_version = 3.13
  warn_unused_config = True
  disallow_incomplete_defs = True
  ```

### 2.2 类型由受支持的操作定义

在 PEP 483 中，类型被认为是一系列值和一系列可操作这些值的函数。在实际操作中，我们可以认为：Python 的**类型由受支持的操作定义**。

例如：

```python
# 一种函数定义
def double(x):
    return x * 2

# 另一种函数定义
def double(x: abc.Sequence):
    return x * 2
```

对于这个函数，参数 `x` 可以是实现了参数为整数的 `__mul__` 方法的任何类型。而对于第二种带类型注释的函数定义，类型检查工具将抛出 error，因为抽象基类 Sequence 并没有实现 `__mul__` 方法。在运行过程中，如果传入的参数不支持 `x * 2` 操作，则会抛出 TypeError。

在渐进式类型系统中，有以下两类相互影响的类型：

- **鸭子类型**（duck typing）：
  - Python、JavaScript、Ruby 等采用这种解读
  - 对象有类型，但是变量（包括参数）没有类型
  - 在实践中，为对象声明的类型无关紧要，重要的是对象具体支持什么操作
  - 只有在运行时尝试操作对象时，才会进行类型相关的检查，但不会在运行时关注声明的类型
  - 这比名义类型更灵活，但运行时可能存在更多潜在的错误
- **名义类型**（nominal typing）：
  - C++、Java、C#、带类型提示的 Python 等支持此种类型
  - 对象和变量都有类型，但对象只存在于运行时
  - 类型检查工具只读取使用类型提示注解变量（包括参数）的源码，而不运行程序的任何部分
  - 因此名义类型会在静态检查阶段，即运行代码之前检测错误，但有时会拒绝实际可运行的代码

### 2.3 注解中可用的类型

可用于注解的主要类型：

- typing.Any
- 简单的类型和类
- typing.Optional 和 typing.Union
- 泛化容器，包括元组和映射
- 抽象基类
- 泛化可迭代对象
- 参数化泛型和 TypeVar
- typing.Protocal —— 静态鸭子类型的关键
- typing.Callable
- typing.NoReturn

#### 2.3.1 Any类型

`Any` 类型是动态类型的基础，即**动态类型**，来自 `typing` 模块。

- 越一般的类型，接口越窄，支持的操作也越少。例如 `x: object` 接受任何类型的参数，但只支持很少的操作
- `Any` 是一种魔术类型，位于类型层次结构的顶部和底部，它既是最一般的类型（用 `n: Any` 注解的参数可接受任何类型的值），也是最特定的类型（支持所有可能的操作）（在类型检查工具看来是这样的）
- 实际上，并不存在支持所有操作的类型，因此使用 `Any` 不利于类型检查工具完成核心任务，即检测潜在的非法操作，防止运行时异常导致程序崩溃

渐进式类型系统中，存在一种名为**相容**（consistent-with）的关系，相容的规则如下：

- 对于 `T1` 及其子类型 `T2`，`T2` 与 `T1` 相容（[里氏替换原则](https://en.wikipedia.org/wiki/Liskov_substitution_principle)，LSP）。任何预期 `T1` 实例的地方都可以使用 `T2` 实例，反过来则不行
- 任何类型都与 `Any` 相容：声明为 `Any` 类型的参数接受任何类型的对象
- `Any` 与任何类型都相容：始终可以把 `Any` 类型的对象传给预期其他类型的参数

#### 2.3.2 简单的类型和类

- 像 `int`、`float`、`str` 和 `bytes` 等简单的类型可以直接在类型提示中使用
- 标准库、外部包中的具体类，以及用户定义的具体类，也可以在类型提示中使用
- 抽象基类在类型提示中也能用到
- 对类来说，**相容**的定义与子类型相似：子类与所有超类相容

#### 2.3.3 Optional类型和Union类型

如果一个函数参数需要兼容两种及以上类型，则需要使用到 `Opyional` 或 `Union`

- 对于可变类型的默认值需要设置为 `None`，此时可使用 
  ````python
  var_name: Optional(mutable_type) = None
  ````

- 使用 `Union` 处理多个类型的句法为
  ```
  var_name: Union(type1, type2, ...) 
  ```

- 从 Python 3.10 开始可以使用下面的句法替代 `Union`
  ```
  var_name: type1 | type2 |...
  ```

- `Union[]` 所含的类型之间不应相容，否则的话就画蛇添足了

#### 2.3.4 泛化容器

大多数 Python 容器是异构的，即容器内项的类型可以是不同的。但实际这样做并没有什么意义，我们往往需要指定容器内项的类型，在 Python 中通过**泛型**(generics) 来实现。

- 基本句法：`container[item_type]`，其中 `item_type` 表示项的类型，`container` 为以下接受泛化类型提示形式的容器中的一种：
  ```python
  list         collections.deque    abc.Sequence    abc.MutableSequence
  set          abc.Container        abc.Set         abc.MutableSet
  frozenset    abc.Collection
  ```

#### 2.3.5 元组类型

元组类型的注解分为以下几种情况：

- 用作记录的元组：使用 `tuple` 注解，字段的类型在 `[]` 内声明
- 带有具名字段，用作记录的元组：强烈建议使用 `typing.NamedTuple`（的子类）注解
  - `typing.NamedTuple`（的子类）是 `tuple` 的子类，因此前者的实例可以通过 Mypy 对 `tuple` 类型的检查
- 用作不可变序列的元组
  - 若想注解长度不定、用作不可变序列的元组，则只能指定一个类型，后跟逗号和 `...`，即形如 `tuple[some_type, ...]`
  - 在类型提示中， `tuple[Any, ...]` 与 `tuple` 等价

#### 2.3.6 泛型映射

泛化映射类型使用 `MappingType[KeyType, ValueType]` 的形式注解（比如 `dict[str, set[str]]`）

- 当把 `dict` 用作记录时，一般情况下所有键都应使用 `str` 类型，而值的类型取决于键的含义

#### 2.3.7 抽象基类

抽象基类的类型提示应遵循**伯斯塔尔定律**(Postel's Law) 或称**稳健性法则**(Robustness Principle)：

- 发送时要保守：函数的返回值始终应该是一个具体对象 / 类型
- 接收时要大方：函数的参数应接受抽象类型，而不是具体类型，这样对调用方来说更加灵活

#### 2.3.8 Iterable

`Iterable` 接受所有的可迭代对象，可以用 `[]` 指明项的类型（泛型），因此很适合作为注解参数的类型。

```python
from collections.abc import Iterable

FromTo = tuple[str, str]

def zip_replace(text: str, changes: Iterable[FromTo]) -> str:
    for from_, to in changes:
        text = text.replace(from_, to)
    return text

# 运行结果
>>> from replacer import zip_replace
>>> l33t = [('a', '4'), ('e', '3'), ('i', '1'), ('o', '0')]
>>> text = 'mad skilled noob powned leet'
>>> zip_replace(text, l33t)
'm4d sk1ll3d n00b p0wn3d l33t'
```

- 在上个例子中，`FromTo` 是一个类型别名，这里将类型直接赋值给了变量，提高可读性

- Python 3.10 还引入了特殊类型 `TypeAlias`，进一步提升可读性，且让类型检查更容易，用法如下：
  ```python
  from typing import TypeAlias
  
  FromTo: TypeAlias = tuple[str, str]
  ```

#### 2.3.9 参数化泛型和 TypeVar

参数化泛型是一种特殊的泛型，句法形如 `container[T]`，其中 `T` 是类型变量，通过 `typing.TypeVar()` 创建（比如 `T = TypeVar('T')`）。

- 每次使用 `T` 时，`T` 都会与具体的类型绑定，这样就可以在结果的类型中使用参数的类型了
- 有时，需要限制可以赋予 `T` 的类型，下面提供几种限制的方法：
  - 受限的 `TypeVar`：`TypeVar` 还可以接受一些为止参数，以对类型参数施加限制
    - 比如 `NumberT = TypeVar('NumberT', float, Decimal, Fraction)` 仅允许 `NumberT` 在 `float` 等三种类型之中
  - 有界的 `TypeVar`：`TypeVar` 提供了一个可选的关键字参数 `bound`，为可接受的类型设定一个上边界
    - 比如当 `bound=Hashable` 时，类型参数可以是 `Hashable` 或它的任何子类型